
- page 146
- O(log n): binary search,
- O(n): simple find
- O(n * log n): 
- O(n*n): selection sort
- O(n!): 旅行商
---
- 合并排序 O (n * log n), 快速排序 最差情况 O(n * n)与选择排序一样慢, 但平均为 O(n * log n)
- 若快速排序在平均情况下的运行是境为O(n * log n), 而合并排序的的运行时间总是 O(n * log n), 为何不使用合并排序？ 它不是更快吗？
    - 算法实际运行时间为 c*O，一般情况下不考虑常量c, 但有时常量影响很大，对于快速排序和合并排序就是如此。快速排序的常量比合并排序小，因此如果它们的复杂度都为O(n * log n), 快速排序的速度将更快。实际中，也更快。因为实际中遇上平均情况的可能性要比最坏情况大得多。

- 广度优先搜索 breadth first search
    - 复杂度: O(人数+边数) 或 O(V + E)
    - 解决：（非加权图） 
        1. 从A节点出发有到达B节点的路径吗？ 
        2. 从A节点出发到达B节点的最短路径？
    - 实现：
        1. 把A节点加入节点队列
        2. 从节点队列取出第一个节点，如果这个节点没有被找过(见第4点)则依次找出其邻居节点，如果是B则找到，如果不是则加入节点队列尾。
        3. 直到找到B，或节点队列为空。
        4. 注意去除环的影响，用一个set来标记该节点是否已经处理过。


- 狄克特斯拉算法 dijkstras algorithm
    - 复杂度：
    - 解决：（无负权边加权图）
        1. 找最快路径
    - 实现
        1. 找出"最便宜"的节点。
        2. 更新该节点的邻居开销(如果新的路径更便宜)
        3. 找出下一个最便宜的节点为，重复这个过程，直到对图中的每个节点都这样做了。
        4. 计算最终路径
    - 负权边
        - 因为狄克特斯拉算法这样假设: 对于处理过的海报节点，没有前往该节点的更短路径。这种假设在仅在没有负权边时才成立。
        - 对于包含负权边的图，可使用：贝尔曼.福德算法(Bellman Ford algorithm)

-  贪婪算法
    - 复杂度
    - 每步都采用最优解，最终得到的就是全局最优解。(并非在任何情况下都行之有效，但它易于实现)
    - 广度优先搜索和狄克特拉算法，属于贪婪算法。
    - 背包问题：(背包可装35磅，力图往其中装入价值最高的商品)
        1. 可装入背包最贵的商品
        2. 再装入可装入最贵的商品。
        3. 这里显然不能获得最优解，但有些时候完美是优秀的敌人，有些时候你只需要一个大致可以解决问题的算法，此时贪婪算法正好可派上用场，因为实现起来很容易。
        4. 背包问题可以用动态规划找到最优解。

- NP 完全问题, 你需要计算所有的解，并从中选出最优的那个。
    - 为解决集合覆盖问题，你必须计算每个可能的集合。
    - 旅行商问题：旅行商需要前往5个不同的城市，要找出最短路径，为此，必须计算每条可能的路径 n! 这里 n=5。
    - NP 完全问题以难解著称，很多人认为根本不可能写出快速解决这些问题的完美算法。(所以经常用近似算法，贪婪算法)
    - 如何识别NP完全问题, 没办法判断问题是不是NP完全问题，但还是有一些特征
        - 元素较少时算法的运行速度非常快，但随着元素数量增加会变得非常慢。
        - 涉及'所有组合'的问题通常是NP完全问题。
        - 不能将问题分成小问题，必须考虑各种可能的情况，可能是NP完全问题。
        - 如果问题涉及序列(如旅行商问题中的城市序列)且难以解决，可能是NP完全问题。
        - 如果问题涉及集合(如广播台集合)且难以解决，可能是NP完全问题。
        - 如果问题可转换为集合覆盖或旅行商问题，那它肯定是NP完全问题。

- 动态规划
    - 第个动态规划都是从一个网格开始的。
