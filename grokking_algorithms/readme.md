#中文名： 算法图解
----
- page 146
- O(log n): binary search,
- O(n): simple find
- O(n * log n):
- O(n*n): selection sort
- O(n!): 旅行商
---
- 合并排序 O (n * log n), 快速排序 最差情况 O(n * n)与选择排序一样慢, 但平均为 O(n * log n)
- 若快速排序在平均情况下的运行是境为O(n * log n), 而合并排序的的运行时间总是 O(n * log n), 为何不使用合并排序？ 它不是更快吗？
    - 算法实际运行时间为 c*O，一般情况下不考虑常量c, 但有时常量影响很大，对于快速排序和合并排序就是如此。快速排序的常量比合并排序小，因此如果它们的复杂度都为O(n * log n), 快速排序的速度将更快。实际中，也更快。因为实际中遇上平均情况的可能性要比最坏情况大得多。

- 广度优先搜索 breadth first search
    - 复杂度: O(人数+边数) 或 O(V + E)
    - 解决：（非加权图）
        1. 从A节点出发有到达B节点的路径吗？
        2. 从A节点出发到达B节点的最短路径？
    - 实现：
        1. 把A节点加入节点队列
        2. 从节点队列取出第一个节点，如果这个节点没有被找过(见第4点)则依次找出其邻居节点，如果是B则找到，如果不是则加入节点队列尾。
        3. 直到找到B，或节点队列为空。
        4. 注意去除环的影响，用一个set来标记该节点是否已经处理过。


- 狄克特斯拉算法 dijkstras algorithm
    - 复杂度：
    - 解决：（无负权边加权图）
        1. 找最快路径
    - 实现
        1. 找出"最便宜"的节点。
        2. 更新该节点的邻居开销(如果新的路径更便宜)
        3. 找出下一个最便宜的节点为，重复这个过程，直到对图中的每个节点都这样做了。
        4. 计算最终路径
    - 负权边
        - 因为狄克特斯拉算法这样假设: 对于处理过的海报节点，没有前往该节点的更短路径。这种假设在仅在没有负权边时才成立。
        - 对于包含负权边的图，可使用：贝尔曼.福德算法(Bellman Ford algorithm)

-  贪婪算法
    - 复杂度
    - 每步都采用最优解，最终得到的就是全局最优解。(并非在任何情况下都行之有效，但它易于实现)
    - 广度优先搜索和狄克特拉算法，属于贪婪算法。
    - 背包问题：(背包可装35磅，力图往其中装入价值最高的商品)
        1. 可装入背包最贵的商品
        2. 再装入可装入最贵的商品。
        3. 这里显然不能获得最优解，但有些时候完美是优秀的敌人，有些时候你只需要一个大致可以解决问题的算法，此时贪婪算法正好可派上用场，因为实现起来很容易。
        4. 背包问题可以用动态规划找到最优解。

- NP 完全问题, 你需要计算所有的解，并从中选出最优的那个。
    - 为解决集合覆盖问题，你必须计算每个可能的集合。
    - 旅行商问题：旅行商需要前往5个不同的城市，要找出最短路径，为此，必须计算每条可能的路径 n! 这里 n=5。
    - NP 完全问题以难解著称，很多人认为根本不可能写出快速解决这些问题的完美算法。(所以经常用近似算法，贪婪算法)
    - 如何识别NP完全问题, 没办法判断问题是不是NP完全问题，但还是有一些特征
        - 元素较少时算法的运行速度非常快，但随着元素数量增加会变得非常慢。
        - 涉及'所有组合'的问题通常是NP完全问题。
        - 不能将问题分成小问题，必须考虑各种可能的情况，可能是NP完全问题。
        - 如果问题涉及序列(如旅行商问题中的城市序列)且难以解决，可能是NP完全问题。
        - 如果问题涉及集合(如广播台集合)且难以解决，可能是NP完全问题。
        - 如果问题可转换为集合覆盖或旅行商问题，那它肯定是NP完全问题。
    - 在一堆人中找出最大的朋友圈(即其中任何两个人都认识)

- 动态规划
    - 将问题分成小问题，并先着手解决这些小问题。
    - 每个动态规划都是从一个网格开始的。
    - 背包问题：
        - i 行(商品) j 列(背包容量)
        - cell[i][j] = max (cell[i-1][j], 当前行商品价值+cell[i-1][j-当前行商品重量])
    - 动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即子问题间无依赖的情况，动态规划才管用。
    - 设计出动态规划的通用tips
        1. 每种动态规划解决方案都涉及网格。
        2. 单元格中的值通常就是你要优化的值。
        3. 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网络的坐标。
    - 最长公共子串， 填充公式 (费曼算法， Feynman algorithm)
        1. 行列坐标分别为两上字符串。
        2. 格子的值，如果行列两个字母不相同，值为0
        3. 如果行列两个字母相同，值为左上角的值+1
        4. 整个表格中的最大值，就是网格中最大的数字。
        5. 伪代码
        ```
        if word_a[i] == word_b[j]:
            cell[i][j] = cell[i-1][j-1] + 1
        else:
            cell[i][j] = 0
        ```
    - 最长公共子序列， 填充公式
        1. 如果行列两个字母不同，就选择上方和左方邻居中较大的那个
        2. 如果行列两个字母相同，就选择左上方单元格的值加1.
        3. 伪代码
        ```
        if word_a[i] == word_b[j]:
            cell[i][j] = cell[i-1][j-1] + 1
        else:
            cell[i][j] = max(cell[i-1][j], cell[i][j-1])
        ```
- KNN
    - 这里计算两位用户的相似度时用的都是距离公式，但实际工作中经常使用的是余弦相似度(cosine similarity)。
    - 挑选合适的特征(以电影为例)
        1. 与要推荐的电影紧密相关的特征
        2. 不偏不倚的特征(例如，如果只让用户给喜剧片打分，说无法判断他们是否喜欢动作片)
        3. 没有放之四海皆准的法则，必须考虑到各种因素。
    - 考虑多少邻居，一个经验什，如果有N位用户，应考虑sqrt(N)个邻居。
    - 机器学习简介，KNN算法堪称你进入机器学习领域的领路人。

- 接下来
    - 二叉树
        1. B树
        2. 红黑树
        3. 堆
        4. 伸展树

    - 反向索引，通常用来创建搜索引擎

    -傅里叶变换：给它一杯冰沙，它能告诉你其中包含哪些成分。

    - 并行算法
        - 并行管理开销
        - 负载均衡

    - 分布式算法(一种特殊的并行算法)
    - MapReduce, 一种流行的分布式算法
        - 映射 map
        - 归并 reduce

    - 布隆过滤器 和 HyperLogLog
        - 布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的。
        - HyperLogLog 是一种类似布隆过滤器的算法。

    - SHA (secure hash algorithm)算法 (字符串散列算法)，用来保存密码，或比较文件是否相等。

    - Simhash 散列算法， 局部敏感，可用来检查两项内容的相似程度。

    - Diffie-Hellman算法 密钥交换
        - 双方无需要知道加密算法，他们不必会面协商要使用的加密算法。
        - 要破解加密的消息比登天还难。
        - 使用用两个密钥：公钥，私钥。

    - RSA算法， Diffie_hellman的替代者

    - 线性规划, Simplex 算法
        - 所有的图算法都可以使用线性规划来实现，线性规划是一个宽泛得多的框架，图问题只是其中一个子集。
