
- page 129
- O(log n): binary search,
- O(n): simple find
- O(n * log n): 
- O(n*n): selection sort
- O(n!): 旅行商
---
- 合并排序 O (n * log n), 快速排序 最差情况 O(n * n)与选择排序一样慢, 但平均为 O(n * log n)
- 若快速排序在平均情况下的运行是境为O(n * log n), 而合并排序的的运行时间总是 O(n * log n), 为何不使用合并排序？ 它不是更快吗？
    - 算法实际运行时间为 c*O，一般情况下不考虑常量c, 但有时常量影响很大，对于快速排序和合并排序就是如此。快速排序的常量比合并排序小，因此如果它们的复杂度都为O(n * log n), 快速排序的速度将更快。实际中，也更快。因为实际中遇上平均情况的可能性要比最坏情况大得多。

- 广度优先搜索 breadth first search
    - 复杂度: O(人数+边数) 或 O(V + E)
    - 解决：（非加权图） 
        1. 从A节点出发有到达B节点的路径吗？ 
        2. 从A节点出发到达B节点的最短路径？
    - 实现：
        1. 把A节点加入节点队列
        2. 从节点队列取出第一个节点，如果这个节点没有被找过(见第4点)则依次找出其邻居节点，如果是B则找到，如果不是则加入节点队列尾。
        3. 直到找到B，或节点队列为空。
        4. 注意去除环的影响，用一个set来标记该节点是否已经处理过。


- 狄克特斯拉算法 dijkstras algorithm
    - 复杂度：
    - 解决：（无负权边加权图）
        1. 找最快路径
    - 实现
        1. 找出"最便宜"的节点。
        2. 更新该节点的邻居开销(如果新的路径更便宜)
        3. 找出下一个最便宜的节点为，重复这个过程，直到对图中的每个节点都这样做了。
        4. 计算最终路径
    - 负权边
        - 因为狄克特斯拉算法这样假设: 对于处理过的海报节点，没有前往该节点的更短路径。这种假设在仅在没有负权边时才成立。
        - 对于包含负权边的图，可使用：贝尔曼.福德算法(Bellman Ford algorithm)
